---
export interface Props {
  delay?: number;
  duration?: number;
  direction?: 'up' | 'down' | 'left' | 'right' | 'fade';
  distance?: number;
  children: any;
}

const { 
  delay = 0, 
  duration = 600, 
  direction = 'up', 
  distance = 50,
  children 
} = Astro.props;

const animationId = `scroll-reveal-${Math.random().toString(36).substr(2, 9)}`;
---

<div 
  class="scroll-reveal" 
  data-delay={delay}
  data-duration={duration}
  data-direction={direction}
  data-distance={distance}
  id={animationId}
>
  <slot />
</div>

<style>
  .scroll-reveal {
    opacity: 0;
    transition: all var(--duration, 600ms) cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }

  .scroll-reveal[data-direction="up"] {
    transform: translateY(var(--distance, 50px));
  }

  .scroll-reveal[data-direction="down"] {
    transform: translateY(calc(-1 * var(--distance, 50px)));
  }

  .scroll-reveal[data-direction="left"] {
    transform: translateX(var(--distance, 50px));
  }

  .scroll-reveal[data-direction="right"] {
    transform: translateX(calc(-1 * var(--distance, 50px)));
  }

  .scroll-reveal[data-direction="fade"] {
    transform: none;
  }

  .scroll-reveal.revealed {
    opacity: 1;
    transform: translate(0, 0);
  }
</style>

<script>
  (function() {
    let observer: IntersectionObserver | null = null;
    const observedElements = new Set<HTMLElement>();

    function initScrollReveal() {
      // Cleanup existing observer
      if (observer) {
        observedElements.forEach(element => {
          observer?.unobserve(element);
        });
        observedElements.clear();
        observer.disconnect();
        observer = null;
      }

      const elements = document.querySelectorAll<HTMLElement>('.scroll-reveal');
      
      if (elements.length === 0) return;

      // Check for reduced motion preference
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      
      observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              const element = entry.target as HTMLElement;
              const delay = prefersReducedMotion ? 0 : parseInt(element.dataset.delay || '0');
              const duration = prefersReducedMotion ? 0 : parseInt(element.dataset.duration || '600');
              
              // Aplicar estilos CSS personalizados
              element.style.setProperty('--duration', `${duration}ms`);
              element.style.setProperty('--distance', `${element.dataset.distance || '50'}px`);
              
              if (prefersReducedMotion) {
                element.classList.add('revealed');
              } else {
                setTimeout(() => {
                  element.classList.add('revealed');
                }, delay);
              }
              
              observer?.unobserve(element);
              observedElements.delete(element);
            }
          });
        },
        {
          threshold: 0.1,
          rootMargin: '0px 0px -50px 0px'
        }
      );

      elements.forEach((element) => {
        // Skip if already revealed
        if (!element.classList.contains('revealed')) {
          observer?.observe(element);
          observedElements.add(element);
        }
      });
    }

    // Inicializar cuando el DOM esté listo
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initScrollReveal);
    } else {
      initScrollReveal();
    }

    // Reinicializar después de transiciones de Astro
    document.addEventListener('astro:after-swap', initScrollReveal);

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (observer) {
        observer.disconnect();
        observer = null;
        observedElements.clear();
      }
    });
  })();
</script>