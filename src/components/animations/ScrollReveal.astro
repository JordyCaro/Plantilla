---
export interface Props {
  delay?: number;
  duration?: number;
  direction?: 'up' | 'down' | 'left' | 'right' | 'fade';
  distance?: number;
  children: any;
}

const { 
  delay = 0, 
  duration = 600, 
  direction = 'up', 
  distance = 50,
  children 
} = Astro.props;

const animationId = `scroll-reveal-${Math.random().toString(36).substr(2, 9)}`;
---

<div 
  class="scroll-reveal" 
  data-delay={delay}
  data-duration={duration}
  data-direction={direction}
  data-distance={distance}
  id={animationId}
>
  <slot />
</div>

<style>
  .scroll-reveal {
    opacity: 0;
    transition: all var(--duration, 600ms) cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }

  .scroll-reveal[data-direction="up"] {
    transform: translateY(var(--distance, 50px));
  }

  .scroll-reveal[data-direction="down"] {
    transform: translateY(calc(-1 * var(--distance, 50px)));
  }

  .scroll-reveal[data-direction="left"] {
    transform: translateX(var(--distance, 50px));
  }

  .scroll-reveal[data-direction="right"] {
    transform: translateX(calc(-1 * var(--distance, 50px)));
  }

  .scroll-reveal[data-direction="fade"] {
    transform: none;
  }

  .scroll-reveal.revealed {
    opacity: 1;
    transform: translate(0, 0);
  }
</style>

<script>
  function initScrollReveal() {
    const elements = document.querySelectorAll('.scroll-reveal');
    
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const element = entry.target as HTMLElement;
            const delay = parseInt(element.dataset.delay || '0');
            const duration = parseInt(element.dataset.duration || '600');
            
            // Aplicar estilos CSS personalizados
            element.style.setProperty('--duration', `${duration}ms`);
            element.style.setProperty('--distance', `${element.dataset.distance || '50'}px`);
            
            setTimeout(() => {
              element.classList.add('revealed');
            }, delay);
            
            observer.unobserve(element);
          }
        });
      },
      {
        threshold: 0.1,
        rootMargin: '0px 0px -50px 0px'
      }
    );

    elements.forEach((element) => {
      observer.observe(element);
    });
  }

  // Inicializar cuando el DOM esté listo
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initScrollReveal);
  } else {
    initScrollReveal();
  }

  // Reinicializar después de transiciones de Astro
  document.addEventListener('astro:after-swap', initScrollReveal);
</script>