---
import { Image } from 'astro:assets';

export interface Props {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  class?: string;
  loading?: 'lazy' | 'eager';
  quality?: number;
  format?: 'webp' | 'avif' | 'png' | 'jpg';
  sizes?: string;
  placeholder?: 'blur' | 'empty';
  blurDataURL?: string;
}

const { 
  src, 
  alt, 
  width = 800, 
  height = 600, 
  class: className = '',
  loading = 'lazy',
  quality = 80,
  format = 'webp',
  sizes = '100vw',
  placeholder = 'blur',
  blurDataURL
} = Astro.props;

// Generate blur placeholder if not provided
const defaultBlurDataURL = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwCdABmX/9k=';
---

<div class="optimized-image-container">
  <Image
    src={src}
    alt={alt}
    width={width}
    height={height}
    class={`optimized-image ${className}`}
    loading={loading}
    quality={quality}
    format={format}
    sizes={sizes}
    {...(placeholder === 'blur' && { 
      placeholder: 'blur',
      blurDataURL: blurDataURL || defaultBlurDataURL
    })}
  />
</div>

<style>
  .optimized-image-container {
    position: relative;
    overflow: hidden;
  }

  .optimized-image {
    transition: transform 0.3s ease, opacity 0.3s ease;
  }

  .optimized-image[loading="lazy"] {
    opacity: 0;
  }

  .optimized-image[loading="lazy"].loaded {
    opacity: 1;
  }

  /* Hover effects */
  .optimized-image-container:hover .optimized-image {
    transform: scale(1.05);
  }

  /* Responsive behavior */
  .optimized-image {
    width: 100%;
    height: auto;
    object-fit: cover;
  }
</style>

<script>
  function initOptimizedImages() {
    const images = document.querySelectorAll('.optimized-image[loading="lazy"]');
    
    const imageObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const img = entry.target as HTMLImageElement;
            
            // Add loaded class when image loads
            img.addEventListener('load', () => {
              img.classList.add('loaded');
            });
            
            // If image is already loaded (cached), add class immediately
            if (img.complete) {
              img.classList.add('loaded');
            }
            
            imageObserver.unobserve(img);
          }
        });
      },
      {
        rootMargin: '50px 0px',
        threshold: 0.01
      }
    );

    images.forEach((img) => {
      imageObserver.observe(img);
    });
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initOptimizedImages);
  } else {
    initOptimizedImages();
  }

  // Reinitialize after Astro transitions
  document.addEventListener('astro:after-swap', initOptimizedImages);
</script>


